---
layout: single
title: "Effective Modern C++ - 형식 영역"
categories: Books
classes: wide
---

## 형식 영역 - Type Deduction

C++ 98부터 존재하던 형식 영역은 템플릿에 관한 내용만 존재하였지만, C++11에서 auto와 decltype이 추가되고 C++14에서는 이들이 확장되었기 때문에 형식 영역에 적용 범위도 증가하였습니다.

형식 영역은 함수 템플릿, auto, decltype 표현식 등에 항상 발생하며, C++14의 경우 decltype(auto) 구성체(둘 이상의 언어 요소로 이루어진 코드 조각)이 쓰이는 곳에서도 발생합니다.

형식 영역을 확실히 이해하지 못한다면 Modern C++에서의 효과적인 프로그래밍이 어렵기 때문에 이 책은 작동 방식을 이해하고 컴파일러가 이를 명시적으로 표시하게 하는 방법을 설명합니다.


## 항목1: 템플릿 연역 형식의 숙지

템플릿 연역 형식 내부 구조는 사용자가 알 필요 없어도 손 쉬운 사용이 가능하도록 구현되어있습니다.

그리고, C++14부터 제공되는 auto는 템플릿에 대한 형식 연역을 기반으로 작동하기 때문에 템플릿이 올바르게 작동하는 환경에서는 auto도 동일하게 문제 없이 작동합니다.

하지만 auto의 형식 연역 규칙은 템플릿보다 덜 직관적인 면모가 있기 때문에 템플릿 형식 연역을 잘 이해하고 auto를 올바르게 사용하는 것이 중요합니다.

템플릿의 선언과 호출은 다음과 같습니다

```cpp
template <typename T>
void f(ParamType param);

f(expr);
```

ParamType을 T로 지정해두지 않는 이유는 다음과 같습니다.

```cpp
template<typename T>
void f(const T& param);

int x = 0;

f(x);
```

이 경우 ParamType은 const T&로 연역되며, T는 int로 연역됩니다.

하지만 항상 이렇게 연역되지 않고 다른 경우도 존재하며, 이는 ParamType의 형태에 따라 세 가지로 분류됩니다.

1. ParamType이 포인터 또는 참조 형식이지만 보편 참조(universal reference)가 아닌 경우.

2. ParamType이 보편 참조인 경우.

3. ParamType이 포인터도 아니고 참조도 아닌 경우.

*보편 참조 (universal reference)?*   
universal reference는 매개변수 선언은 T&&의 형태로 오른값 참조와 같은 형태이지만, 왼값 인수가 전달된다면 오른값 인수와 다른 방식으로 작동합니다.


**ParamType이 포인터 또는 참조 형식이지만 보편 참조가 아닌 경우**

가장 간단한 경우이며, 형식 연역은 다음과 같이 진행됩니다.

1. expr이 참조 형식이면 참조 부분을 무시합니다.

2. expr의 형식을 ParamType에 대해 패턴 부합(pattern-matching) 방식으로 대응하여 T의 형식을 결정합니다.

**예시)**
```cpp
template <typename T>
void f(T& param);

int x = 27;         // x는 int
const int cx = x;   // cx는 const int
const int& rx = x;  // rx는 const int인 x에 대한 참조

f(x);               // T는 int, ParamType은 int&
f(cx);              // T는 const int, ParamType은 const int&
f(rx);              // T는 const int, ParamType은 const int&
```

const 값이 배정되는 경우, const-ness를 보장하기 위해 const는 유지되며 rx와 cx는 T에 const가 포함됩니다.   
그리고 reference-ness는 무시되기 때문에 rx의 경우에 T에 &가 없이 const int로 연역되었음을 알 수 있습니다.

Pointer와 Reference는 동일하게 적용됩니다.


**ParamType이 universal reference인 경우**

이 경우에는 왼값 인수와 오른값 인수에 대해 다른 방식으로 행동하게 됩니다.

expr이 오른값인 경우에는 1번과 동일하게 적용되며, 왼값인 경우에는 T와 ParamType 둘다 왼값 참조로 연역되게 됩니다.

이 상황은 이질적인 상황으로 판별되는데, 그 이유는 템플릿 형식 연역에서 T가 참조 형식으로 되는 것은 이 경우가 유일하며, ParamType은 T&&로 오른값 참조 형태를 갖지만 연역된 형식은 왼값 참조가 되기 때문입니다.

**예시)**
```cpp
template <typename T>
void f(T&& param);

int x = 27;         // x는 int
const int cx = x;   // cx는 const int
const int& rx = x;  // rx는 const int인 x에 대한 참조

f(x);               // x는 왼값, T는 int&, ParamType는 int&
f(cx);              // cx는 왼값, T는 const int&, ParamType는 const int&
f(rx);              // rx는 왼값, T는 const int&, ParamType는 const int&
f(27);              // 27은 오른값, T는 int, ParamType는 int&&
```


**ParamType가 포인터도 아니고 참조도 아닌 경우**

포인터도 아니고 참조도 아닌 경우는 값 전달의 경우이기 때문에 새로운 객체이며, 다음과 같은 규칙이 적용됩니다.

1. expr의 형식이 참조라면, 참조 부분을 무시합니다.

2. expr의 참조성을 무시한 후, expr이 const라면 const도 무시합니다. volatile이라면 그 역시 무시합니다.

*주의점*   
주의 해야할 점은 포인터 변수를 전달할 때 발생합니다.

아래와 같이 const char* const ptr 변수는 ptr의 주솟값을 변경할 수 없고, 주솟값이 가리키는 문자열도 변경할 수 없는 변수입니다.

하지만 값 전달로 들어가며 포인터에 대한 const는 무시되기 때문에, 형식 연역은 const char*가 되어 변경할 수 있는 포인터 변수로 들어가게 됩니다.

**예시)**
```cpp
template <typename T>
void f(T param);

int x = 27;         // x는 int
const int cx = x;   // cx는 const int
const int& rx = x;  // rx는 const int인 x에 대한 참조

f(x);               // T와 ParamType은 int
f(cx);              // T와 ParamType은 int
f(rx);              // T와 ParamType은 int

//주의점
const char* const ptr = "Fun with Pointers";
```

## 배열 인수 (Array Parameter)

배열 인수는 포인터 형태로 사용할 수 있는 형식의 틈새로 인해 발생할 수 있는 문제가 존재합니다.

배열을 이름으로 사용하면 포인터 변수로 사용하게 되는데, 이는 배열이 배열의 첫 원소를 가리키는 포인터로 붕괴(decay)한다고 말합니다.

이 형식은 아래와 같은 코드를 문제 없이 컴파일하게 됩니다.

```cpp
const char name[] = "J. P. Briggs"; // const char[13] 형태
const char * ptrToName = name; // 배열이 포인터로 붕괴하게 된다
```

코드는 일반적인 상황에서는 문제없이 잘 작동합니다. 하지만 위 변수를 매개변수로 전달하는 경우를 고려해야합니다.

아래의 두 함수는 같은 매개변수를 갖습니다.    
```cpp
void f(int pararm[]) == void f(int* param)
```

그렇기에 위의 const char name 변수를 넣는다면 T는 배열이 아닌 const char*로 연역됩니다.

이를 배열 자체 형식으로 연역하기 위해 사용할 수 있는 교묘한 요령이 있습니다. 바로 매개변수를 참조로 받는 것입니다.

```cpp
template <typename T>
void f(T& param);
```

매개변수를 참조로 받는다면 T의 형식은 배열 그 자체가 되며, 예시로 name을 넣는다면 T는 const char[13], ParamType은 const char&[13]이 되게 됩니다.

이를 통해 다음과 같이 컴파일 시간에 배열에 담긴 원소 갯수를 연역하는 템플릿을 만들 수 있습니다.

```cpp
template <typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept // constexpr은 함수 호출의 결과를 컴파일 때 사용할 수 있게 합니다.
{
  return N;
}
```


## 함수 인수 (Function Parameter)
