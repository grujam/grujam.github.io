---
layout: single
title: "백준/2156번/포도주 시식/실버1"
categories: CodingTest
---

Problem Link: <https://www.acmicpc.net/problem/2156>

### 문제 설명
Site: Baekjoon   
Number: 2156   
Category: Dynamic Programming   
Rank: Silver 1

일렬로 놓아져 있는 포도주를 마시는데, 3잔을 연속으로 마실 수 없다.   
이 때 마실 수 있는 포도주의 최댓값을 구하는 문제.

포도주의 잔의 갯수는 1~10000개.   
포도주의 양은 1000이하 음이 아닌 정수.

DP 배열을 사용해서 풀 수 있는 문제이다.   
보통 이런 유형의 DP문제는 배열 인덱스를 늘려가며 해당 와인잔을 마셨을 때를 가정하여 최댓값을 저장한다.   
처음에 와인잔을 무조건 마셨을 때를 가정하고 두칸 전의 와인잔을 마셨을때와, 세칸전과 한칸전을 마셨을때를 가정하고 비교하며 진행하였다.   
이 경우, 와인잔을 마시지 않고 넘어가는 경우를 계산하지 않아 오답이 난다.

**Wrong Code**
```C
#include <iostream>
#include <algorithm>

using namespace std;

int wines[10000];
int dp[10000];

int main()
{
	ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

	int N, ans = 0;
	cin >> N;

	for (int i = 0; i < N; i++)
		cin >> wines[i];

	dp[0] = wines[0];
	dp[1] = wines[0] + wines[1];
	dp[2] = max(max(wines[0] + wines[2], wines[1] + wines[2]), wines[0] + wines[1]);

	ans = max(max(dp[0], dp[1]), dp[2]);

	for(int i = 3; i < N; i++)
	{
		dp[i] = max(dp[i - 2] + wines[i], dp[i - 3] + wines[i - 1] + wines[i]);
		ans = max(ans, dp[i]);
	}


	cout << ans;

	return 0;
}
```

반례   

    10   
    0   
    0   
    10   
    0   
    5   
    10   
    0   
    0   
    1   
    10   

출력   

    35

정답   

    36

와인잔을 마시지 않은 경우를 고려하여 최댓값을 계속 갱신하는 경우까지 고려한다면 정답이 나온다.

**Answer Code**
```C
#include <iostream>
#include <algorithm>

using namespace std;

int wines[10000];
int dp[10000];

int main()
{
	ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

	int N, ans = 0, idx;
	cin >> N;

	for (int i = 0; i < N; i++)
		cin >> wines[i];

	dp[0] = wines[0];
	dp[1] = wines[0] + wines[1];
	dp[2] = max(max(wines[0] + wines[2], wines[1] + wines[2]), wines[0] + wines[1]);


	ans = max(max(dp[0], dp[1]), dp[2]);

	for(int i = 3; i < N; i++)
	{
		dp[i] = max(max(dp[i - 2] + wines[i], dp[i - 3] + wines[i - 1] + wines[i]), dp[i-1]);
	}

	cout << dp[N-1];

	return 0;
}
```

![백준2156번](/assets/images/CodingTest/백준2156번.PNG)
